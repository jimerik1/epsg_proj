CRS Transformation Platform (PyProj + FastAPI + React)

Overview
- Cloud-ready backend + frontend stack for high-accuracy coordinate transforms (including custom CRS definitions and local trajectory handling).
- Backend exposes FastAPI endpoints powered by PyProj/PROJ 9.x; frontend React UI visualises and validates results.
- Supports ECEF-based local offsets, EPSG lookups, custom CRS parsing/matching, grid factors, and projected/geodetic analytics.
- Docker-first workflow: `docker-compose up --build` brings up backend, frontend, and Redis.

Quick Start
- Requirements: Docker + Docker Compose with network access for grid downloads.
- Run: `docker-compose up --build`
- Backend: http://localhost:3001 (FastAPI/OpenAPI at `/docs`)
- Frontend: http://localhost:3000

Environment
- Backend enables `PROJ_NETWORK=ON` to fetch grids on the fly.
- Redis (optional caching) exposed as `redis:6379` inside the compose network.

Development Notes
- Hot reload via bind mounts for both backend and frontend containers.
- Python deps in `backend/requirements.txt`; Node deps in `frontend/package.json`.
- Frontend uses Tailwind for styling (wired via PostCSS/webpack; no manual step required when using Docker Compose).

Testing
- Example PyProj smoke test in `backend/tests/test_transformations.py`.
- Run inside backend container: `pytest -q`.

Local Trajectories (ECEF vs Scale)
- Endpoint: `POST /api/transform/local-trajectory`
  - Inputs: projected CRS (`crs`), site `reference` (either `x/y[/height]` or `lon/lat[/height]`), and a list of trajectory `points` with local offsets `{ east, north, tvd }` in meters (`tvd` is positive down; the API converts internally to up).
  - Modes:
    - `ecef` (recommended): applies ENU→ECEF about the site and maps through the target CRS. Accurate on long horizontals; inherently handles curvature and convergence.
    - `scale`: single‑point scale approximation. Uses PROJ meridional/parallel scale factors at the site. Fast but may drift on long horizontals as factors vary with position.
    - `both`: returns both branches plus a `difference` block for QA.
  - Notes:
    - If your local EN offsets are referenced to grid north, rotate true↔grid as needed using `/api/calculate/grid-convergence` at the site.
    - Performance: thousands to tens of thousands of points per call are fine for both methods.
  - Planned: a `scale_continuous` mode that recomputes scale factors per step to reduce drift (see TODO.md).

API Reference (summary – see `docs/` for full details)

| Endpoint | Method | Description |
| --- | --- | --- |
| [`/api/transform/direct`](docs/transform_direct.md) | POST | Transform single position from source CRS to target CRS. |
| [`/api/transform/available-paths`](docs/transform_direct.md) | GET | List available transformation paths between two CRS. |
| [`/api/transform/available-paths-via`](docs/transform_available_paths_via.md) | GET | List available paths for source→via and via→target legs. |
| [`/api/transform/trajectory`](docs/transform_trajectory.md) | POST | Bulk transform a trajectory between two CRS. |
| [`/api/transform/via`](docs/transform_via.md) | POST | Step through a user-defined CRS path (A → B → C). |
| [`/api/transform/available-paths`](docs/transform_direct.md) | GET | List available transformation paths between two CRS. |
| [`/api/transform/available-paths-via`](docs/transform_available_paths_via.md) | GET | List available paths for source→via and via→target legs. |
| [`/api/transform/custom`](docs/transform_custom.md) | POST | Transform using a custom CRS supplied as XML. |
| [`/api/transform/local-offset`](docs/transform_local_offset.md) | POST | Apply ECEF + scale-factor comparison for a single ENU offset. |
| [`/api/transform/local-trajectory`](docs/transform_local_trajectory.md) | POST | Apply ECEF/scale pipelines to an entire trajectory. |
| [`/api/crs/info`](docs/crs_info.md) | GET | Retrieve CRS metadata (datum, ellipsoid, axes). |
| [`/api/crs/units`](docs/crs_units.md) | GET | Fetch axis units and conversion factors. |
| [`/api/crs/search`](docs/crs_search.md) | GET | Search CRS definitions by text, AOI, or type. |
| [`/api/crs/parameters`](docs/crs_parameters.md) | GET | Inspect projection parameters for a CRS. |
| [`/api/crs/match`](docs/crs_match.md) | POST | Score best EPSG matches for custom XML definitions. |
| [`/api/crs/parse-custom`](docs/crs_parse_custom.md) | POST | Parse XML into PROJ string and summarised metadata. |
| [`/api/calculate/grid-convergence`](docs/calc_grid_convergence.md) | POST | Compute meridian convergence at a location. |
| [`/api/calculate/scale-factor`](docs/calc_scale_factor.md) | POST | Return meridional/parallel/areal scale factors. |
| `/api/transform/vertical` | POST | Vertical transformations: ellipsoidal↔vertical CRS (experimental). |

GIGS Reports and Runner
- View: `GET /api/gigs/report` (JSON), `GET /api/gigs/report/html` (HTML).  Artifacts are generated by the manual runner.
- Run in backend (dev only): `POST /api/gigs/run` executes `tests/gigs/run_manual.py` to regenerate artifacts.
- The frontend includes a “GIGS Reports” page (tab in the header) that:
  - Shows a summary and a filtered table by series (2200/3200/5100/5200/5500/…)
  - Displays a case breakdown modal (payloads, deltas, expected/actual, endpoint/path)
  - Embeds the HTML report for deep inspection
- Artifacts live at `tests/gigs/gigs_manual_report.json` and `tests/gigs/gigs_manual_report.html` by default. Backend uses `GIGS_REPORT_DIR` (defaults to that path) to locate them.
- Backend resolver now recognises the synthetic GIGS projected CRS aliases (`GIGS:projCRS_A2`, `GIGS:projCRS_A23`, …) so both the APIs and the manual harness can call them directly without hand-mapping to EPSG codes.
- Wells harness realigns input/output tables by point label (skipping orphan SRP rows) and posts full local-trajectory payloads. Horizontal fits for the grid-north deviated wells still need refinement—see `TODO.md` for the remaining work.

Current Status (Oct 2025)
- 5100: green for wired datasets.
- 5200: most green; outstanding work on 5205 (Molodensky‑Badekas), 5207 (NTv2 grid selection/pinning), 5213 (2D three‑translation). See TODO.md for specific path pinning.
- 5500: majority pass; remaining grid‑azimuth wells under review. Local trajectory endpoints support both ECEF and scale; ECEF is authoritative for modeling.

Path Selection and Deterministic Pipelines
- Direct transforms: `/api/transform/direct` accepts `path_id` (TransformerGroup index) and `preferred_ops` (list of substrings to match an operation/method).
- Via transforms: `/api/transform/via` accepts `segment_path_ids` and `segment_preferred_ops` aligned to each leg.
- Introspection: `/api/transform/available-paths` and `/api/transform/available-paths-via` return transformers with `accuracy`, `accuracy_unit`, `description`, and `operations_info` (EPSG codes/method names when available).

Frontend Features (highlights)
- Transform Via page:
  - Define multiple vias; list and pick specific pipelines per leg with accuracy display
  - Suggestions for via candidates (WGS84/WGS84 3D/ECEF and source/target geodetic CRS)
  - Quick-test each leg and run the full via transform
- Transform page: optional path selector for deterministic direct transforms
- Custom CRS and Local Offset pages have been restyled with Tailwind and consistent controls

Environment
- Backend honors `GIGS_REPORT_DIR` to serve GIGS artifacts. In Docker Compose this mounts `./tests/gigs` read-only to `/app/gigs_reports`.
